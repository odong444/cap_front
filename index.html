"""
ìº¡ì±  Selenium Worker - ìœˆë„ìš° PC ì‹¤í–‰ìš©
Railway API ì„œë²„ì™€ í†µì‹ í•˜ë©° ë¸Œë¼ìš°ì € ìž‘ì—… ìˆ˜í–‰
"""

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from webdriver_manager.chrome import ChromeDriverManager
import requests
import time
import re
import json
import os
from datetime import datetime

# ==================== ì„¤ì • ====================
# Railway API ì„œë²„ URL
API_SERVER = "https://capapi-production.up.railway.app"

# ìƒí’ˆ ê²€ìƒ‰ API (ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´)
PRODUCT_API = "https://cells-ing-battery-cms.trycloudflare.com"

# ë„¤ì´ë²„ ê³„ì •
ACCOUNT_FILE = "naver_account.txt"

# ChromeDriver ê²½ë¡œ ìºì‹œ
CHROMEDRIVER_PATH = None


def find_chromedriver_path():
    """ChromeDriver ê²½ë¡œ ì°¾ê¸° (integrated_server.pyì™€ ë™ì¼)"""
    raw_path = ChromeDriverManager().install()
    print(f"[DEBUG] raw_path: {raw_path}")
    
    if raw_path.endswith('chromedriver.exe'):
        return raw_path
    
    dir_path = os.path.dirname(raw_path)
    chromedriver_exe = os.path.join(dir_path, 'chromedriver.exe')
    
    if os.path.exists(chromedriver_exe):
        return chromedriver_exe
    
    # .wdm í´ë”ì—ì„œ ì°¾ê¸°
    wdm_base = os.path.expanduser("~/.wdm/drivers/chromedriver")
    if os.path.exists(wdm_base):
        for root, dirs, files in os.walk(wdm_base):
            if 'chromedriver.exe' in files:
                return os.path.join(root, 'chromedriver.exe')
    
    raise FileNotFoundError("chromedriver.exeë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")


class CaptchaWorker:
    def __init__(self):
        self.driver = None
        self.logged_in = False
        
    def setup_driver(self):
        """Selenium ë“œë¼ì´ë²„ ì„¤ì •"""
        global CHROMEDRIVER_PATH
        
        if self.driver:
            return self.driver
            
        chrome_options = Options()
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-blink-features=AutomationControlled')
        chrome_options.add_experimental_option('excludeSwitches', ['enable-automation'])
        
        # ChromeDriver ê²½ë¡œ ì°¾ê¸°
        if CHROMEDRIVER_PATH is None:
            CHROMEDRIVER_PATH = find_chromedriver_path()
            print(f"â„¹ï¸ ChromeDriver ê²½ë¡œ: {CHROMEDRIVER_PATH}")
        
        self.driver = webdriver.Chrome(
            service=Service(CHROMEDRIVER_PATH),
            options=chrome_options
        )
        
        self.driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
            'source': 'Object.defineProperty(navigator, "webdriver", {get: () => undefined})'
        })
        
        print("âœ… ë¸Œë¼ìš°ì € ì‹œìž‘")
        return self.driver
    
    def login_naver(self):
        """ë„¤ì´ë²„ ë¡œê·¸ì¸"""
        if self.logged_in:
            return True
            
        self.setup_driver()
        self.driver.get("https://nid.naver.com/nidlogin.login")
        time.sleep(2)
        
        # ì´ë¯¸ ë¡œê·¸ì¸ ìƒíƒœë©´ íŒ¨ìŠ¤
        if "nid.naver.com" not in self.driver.current_url:
            self.logged_in = True
            return True
        
        # ìžë™ ë¡œê·¸ì¸ ì‹œë„
        if os.path.exists(ACCOUNT_FILE):
            try:
                import pyperclip
                
                with open(ACCOUNT_FILE, 'r', encoding='utf-8') as f:
                    lines = f.read().strip().split('\n')
                
                if len(lines) >= 2:
                    naver_id, naver_pw = lines[0].strip(), lines[1].strip()
                    
                    print(f"   ìžë™ ë¡œê·¸ì¸: {naver_id[:3]}***")
                    
                    id_input = self.driver.find_element(By.ID, "id")
                    id_input.click()
                    time.sleep(0.3)
                    pyperclip.copy(naver_id)
                    id_input.send_keys(Keys.CONTROL, 'v')
                    time.sleep(0.5)
                    
                    pw_input = self.driver.find_element(By.ID, "pw")
                    pw_input.click()
                    time.sleep(0.3)
                    pyperclip.copy(naver_pw)
                    pw_input.send_keys(Keys.CONTROL, 'v')
                    time.sleep(0.5)
                    
                    login_btn = self.driver.find_element(By.ID, "log.login")
                    login_btn.click()
                    time.sleep(3)
            except Exception as e:
                print(f"   ìžë™ ë¡œê·¸ì¸ ì‹¤íŒ¨: {e}")
        
        # ë¡œê·¸ì¸ ì™„ë£Œ ëŒ€ê¸°
        if "nid.naver.com" in self.driver.current_url:
            print("\nâš ï¸ ë¸Œë¼ìš°ì €ì—ì„œ ë¡œê·¸ì¸ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.")
            input("   ë¡œê·¸ì¸ ì™„ë£Œ í›„ Enter...")
        
        self.logged_in = True
        print("âœ… ë„¤ì´ë²„ ë¡œê·¸ì¸ ì™„ë£Œ")
        return True
    
    def extract_store_url(self, product_url):
        """ìƒí’ˆ URLì—ì„œ ìŠ¤í† ì–´ URL ì¶”ì¶œ"""
        match = re.search(r'(smartstore|brand)\.naver\.com/([^/]+)/', product_url)
        if match and match.group(2) != 'main':
            return f"https://{match.group(1)}.naver.com/{match.group(2)}"
        
        # mainì´ë©´ ë¦¬ë‹¤ì´ë ‰íŠ¸ ë”°ë¼ê°€ê¸°
        if '/main/products/' in product_url:
            try:
                headers = {"User-Agent": "Mozilla/5.0"}
                response = requests.get(product_url, headers=headers, allow_redirects=True, timeout=10)
                match = re.search(r'(smartstore|brand)\.naver\.com/([^/]+)/', response.url)
                if match and match.group(2) != 'main':
                    return f"https://{match.group(1)}.naver.com/{match.group(2)}"
            except:
                pass
        return product_url
    
    def extract_uid(self, store_url):
        """ìŠ¤í† ì–´ URLì—ì„œ UID ì¶”ì¶œ"""
        try:
            self.driver.get(store_url)
            time.sleep(2)
            
            html = self.driver.page_source
            match = re.search(r'"channelUid"\s*:\s*"([^"]+)"', html)
            if match:
                return match.group(1)
            return None
        except:
            return None
    
    def search_and_add_tasks(self, keyword, max_count=50):
        """í‚¤ì›Œë“œ ê²€ìƒ‰ í›„ Railwayì— ìž‘ì—… ì¶”ê°€"""
        print(f"\nðŸ” '{keyword}' ê²€ìƒ‰ ì¤‘...")
        
        try:
            response = requests.get(
                f"{PRODUCT_API}/api/product-score",
                params={"keyword": keyword},
                timeout=60
            )
            
            if response.status_code != 200:
                print(f"âŒ API ì˜¤ë¥˜: {response.status_code}")
                return 0
            
            items = response.json().get('result', {}).get('products', [])
            added = 0
            seen = set()
            
            for item in items[:max_count]:
                link = item.get('link', '') or item.get('mobileLink', '')
                mall_name = item.get('mallName', '')
                
                if 'smartstore.naver.com' in link or 'brand.naver.com' in link:
                    store_url = self.extract_store_url(link)
                    if store_url in seen or '/main' in store_url:
                        continue
                    seen.add(store_url)
                    
                    # UID ì¶”ì¶œ
                    uid = self.extract_uid(store_url)
                    if not uid:
                        continue
                    
                    # Railway APIì— ìž‘ì—… ì¶”ê°€
                    try:
                        resp = requests.post(f"{API_SERVER}/api/worker/add-task", json={
                            'uid': uid,
                            'store_name': mall_name,
                            'store_url': store_url,
                            'keyword': keyword,
                        }, timeout=10)
                        
                        if resp.status_code == 200:
                            task_id = resp.json().get('task_id')
                            added += 1
                            print(f"   âœ… [{added}] {mall_name} (task_id: {task_id})")
                            
                            # ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ
                            self.upload_captcha_screenshot(task_id, uid)
                    except Exception as e:
                        print(f"   âŒ API ì˜¤ë¥˜: {e}")
            
            print(f"âœ… {added}ê°œ ìž‘ì—… ì¶”ê°€ë¨")
            return added
            
        except Exception as e:
            print(f"âŒ ê²€ìƒ‰ ì˜¤ë¥˜: {e}")
            return 0
    
    def upload_captcha_screenshot(self, task_id, uid):
        """ìº¡ì±  ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ"""
        try:
            url = f"https://shopping.naver.com/popup/seller-info/{uid}/profile"
            self.driver.get(url)
            time.sleep(2)
            
            # ë°”ë¡œ í†µê³¼ë˜ëŠ”ì§€ í™•ì¸
            if self.check_captcha_success():
                # ìº¡ì±  ì—†ì´ ë°”ë¡œ ìˆ˜ì§‘
                seller_info = self.parse_seller_info()
                requests.post(f"{API_SERVER}/api/worker/complete-task", json={
                    'task_id': task_id,
                    'success': True,
                    'seller_info': seller_info,
                }, timeout=10)
                print(f"      â†’ ìº¡ì±  ì—†ì´ ë°”ë¡œ ì™„ë£Œ")
                return
            
            # ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ
            screenshot = self.driver.get_screenshot_as_base64()
            requests.post(f"{API_SERVER}/api/worker/upload-screenshot", json={
                'task_id': task_id,
                'screenshot': screenshot,
            }, timeout=30)
            print(f"      â†’ ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
            
        except Exception as e:
            print(f"      â†’ ìŠ¤í¬ë¦°ìƒ· ì‹¤íŒ¨: {e}")
    
    def check_captcha_success(self):
        """ìº¡ì±  í†µê³¼ í™•ì¸"""
        try:
            page_source = self.driver.page_source
            if re.search(r'\d{3}-?\d{2}-?\d{5}', page_source) and 'ì‚¬ì—…ìžë“±ë¡ë²ˆí˜¸' in page_source:
                return True
            if 'ìƒí˜¸ëª…' in page_source and 'ëŒ€í‘œìž' in page_source:
                return True
            return False
        except:
            return False
    
    def parse_seller_info(self):
        """íŒë§¤ìž ì •ë³´ íŒŒì‹±"""
        info = {}
        try:
            body_text = self.driver.find_element(By.TAG_NAME, 'body').text
            
            patterns = {
                'seller_name': r'ìƒí˜¸ëª…\s*([^\n]+)',
                'business_number': r'ì‚¬ì—…ìžë“±ë¡ë²ˆí˜¸\s*(\d{10}|\d{3}-\d{2}-\d{5})',
                'representative': r'ëŒ€í‘œìž\s*([^\n]+)',
                'phone': r'ê³ ê°ì„¼í„°\s*([\d\-]+)',
                'email': r'e-?mail\s*([^\s\n]+@[^\s\n]+)',
                'address': r'ì‚¬ì—…ìž¥\s*ì†Œìž¬ì§€\s*([^\n]+)',
            }
            
            for field, pattern in patterns.items():
                match = re.search(pattern, body_text, re.IGNORECASE)
                if match:
                    info[field] = match.group(1).strip()
            
            # ì‚¬ì—…ìžë“±ë¡ë²ˆí˜¸ í¬ë§·
            bn = info.get('business_number', '')
            if bn and len(bn) == 10:
                info['business_number'] = f"{bn[:3]}-{bn[3:5]}-{bn[5:]}"
            
            return info
        except:
            return info
    
    def process_pending_answers(self):
        """ìœ ì €ê°€ ìž…ë ¥í•œ ë‹µ ì²˜ë¦¬"""
        # pending ìƒíƒœì§€ë§Œ user_answerê°€ ìžˆëŠ” ìž‘ì—…ë“¤ ì²˜ë¦¬
        # ì´ ë¶€ë¶„ì€ DB í´ë§ ë˜ëŠ” WebSocketìœ¼ë¡œ êµ¬í˜„
        pass
    
    def answer_loop(self):
        """ìœ ì € ë‹µë³€ ì²˜ë¦¬ ë£¨í”„ (ë³„ë„ ìŠ¤ë ˆë“œ)"""
        print("\nðŸ”„ ë‹µë³€ ì²˜ë¦¬ ë£¨í”„ ì‹œìž‘...")
        
        while True:
            try:
                # assigned ìƒíƒœì¸ ìž‘ì—… í™•ì¸ (í´ë§)
                resp = requests.get(f"{API_SERVER}/api/worker/pending-answers", timeout=10)
                
                if resp.status_code == 200:
                    tasks = resp.json().get('tasks', [])
                    
                    for task in tasks:
                        task_id = task['id']
                        uid = task['uid']
                        answer = task['user_answer']
                        
                        print(f"\nðŸ“ ë‹µë³€ ì²˜ë¦¬: task {task_id}, ë‹µ: {answer}")
                        
                        # ìº¡ì±  íŽ˜ì´ì§€ë¡œ ì´ë™
                        url = f"https://shopping.naver.com/popup/seller-info/{uid}/profile"
                        self.driver.get(url)
                        time.sleep(1)
                        
                        # ë‹µ ìž…ë ¥
                        try:
                            input_field = self.driver.find_element(By.CSS_SELECTOR, 'input[type="text"], input[type="number"]')
                            input_field.clear()
                            input_field.send_keys(answer)
                            input_field.send_keys(Keys.ENTER)
                            time.sleep(1.5)
                            
                            if self.check_captcha_success():
                                seller_info = self.parse_seller_info()
                                seller_info['store_name'] = task.get('store_name')
                                seller_info['store_url'] = task.get('store_url')
                                
                                requests.post(f"{API_SERVER}/api/worker/complete-task", json={
                                    'task_id': task_id,
                                    'success': True,
                                    'seller_info': seller_info,
                                }, timeout=10)
                                print(f"   âœ… ì„±ê³µ!")
                            else:
                                # ì˜¤ë‹µ - ìƒˆ ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ
                                self.driver.refresh()
                                time.sleep(2)
                                screenshot = self.driver.get_screenshot_as_base64()
                                
                                requests.post(f"{API_SERVER}/api/worker/retry-task", json={
                                    'task_id': task_id,
                                    'screenshot': screenshot,
                                }, timeout=30)
                                print(f"   âŒ ì˜¤ë‹µ, ìž¬ì‹œë„")
                        except Exception as e:
                            print(f"   âŒ ìž…ë ¥ ì‹¤íŒ¨: {e}")
                
                time.sleep(2)  # 2ì´ˆë§ˆë‹¤ í´ë§
                
            except Exception as e:
                print(f"ë‹µë³€ ë£¨í”„ ì˜¤ë¥˜: {e}")
                time.sleep(5)
    
    def run(self, keywords):
        """ë©”ì¸ ì‹¤í–‰"""
        print("="*60)
        print("ðŸš€ ìº¡ì±  Worker ì‹œìž‘")
        print(f"   API ì„œë²„: {API_SERVER}")
        print(f"   í‚¤ì›Œë“œ: {keywords}")
        print("="*60)
        
        # ë¸Œë¼ìš°ì € ì‹œìž‘ & ë¡œê·¸ì¸
        self.setup_driver()
        self.login_naver()
        
        # í‚¤ì›Œë“œ ê²€ìƒ‰ & ìž‘ì—… ì¶”ê°€
        for keyword in keywords:
            self.search_and_add_tasks(keyword)
            time.sleep(3)
        
        # ë‹µë³€ ì²˜ë¦¬ ë£¨í”„
        print("\n" + "="*60)
        print("ðŸ“ ë‹µë³€ ëŒ€ê¸° ì¤‘... (Ctrl+Cë¡œ ì¢…ë£Œ)")
        print("="*60)
        
        self.answer_loop()
    
    def close(self):
        if self.driver:
            self.driver.quit()


# ==================== ë©”ì¸ ====================
if __name__ == '__main__':
    import sys
    
    keywords = sys.argv[1:] if len(sys.argv) > 1 else ['ì•µê¸€', 'ì² ì œì„ ë°˜']
    
    worker = CaptchaWorker()
    try:
        worker.run(keywords)
    except KeyboardInterrupt:
        print("\nì¢…ë£Œ...")
    finally:
        worker.close()
